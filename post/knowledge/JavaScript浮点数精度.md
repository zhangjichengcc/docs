# JavaScript 浮点数精度

?> 0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。

## 数字类型

> ECMAScript 中的 `Number` 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。

?> 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位来储存一个浮点数。

## 浮点数转二进制

我们来看一下 1020 的表示方法

- 10进制

  $ 1020 = 1*10^3+0*10^2+2*10^1+0*10^0 $

  $ \Longrightarrow 1020 $

- 2进制

  $ 1020 = 1*2^9+1*2^8+1*2^7+1*2^6+1*2^5+1*2^4+1*2^3+1*2^2+0*2^1+0*2^0 $

  $ \Longrightarrow 1111111100 $

那如果是 0.75 用二进制表示呢？同理应该是：

$ 0.75 = a*2^-1+b*2^-2+c*2^-3+d*2^-4+... $

因为使用的是二进制，这里的 abcd…… 的值的要么是 0 要么是 1。

那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下：

$ 0.75 = a*2^-1+b*2^-2+c*2^-3+d*2^-4... $

两边同时乘以 2

$ 1 + 0.5 = a\*\2^0\+\b\*\2^-1\+\c\*\2^-2\+\d\*\2^-3... (所以 a = 1) $

剩下的：

$ 0.5 = b*2^-1+c*2^-2+d*2^-3... $

再同时乘以 2

$ 1 + 0 = b*2^0+c*2^-2+d*2^-3... (所以 b = 1) $

所以 0.75 用二进制表示就是 0.ab，也就是 0.11

然而不是所有的数都像 0.75 这么好算, 我们来算下 0.1：

``` 

$ 0.1 = a*2^{-1}+b*2^{-2}+c*2^{-3}+d*2^{-4}+ ... $  

$ 0 + 0.2 = a*2^0+b*2^{-1}+c*2^{-2}+ ...   (a = 0) $  
$ 0 + 0.4 = b*2^0+c*2^{-1}+d*2^{-2}+ ...   (b = 0) $  
$ 0 + 0.8 = c*2^0+d*2^{-1}+e*2^{-2}+ ...   (c = 0) $  
$ 1 + 0.6 = d*2^0+e*2^{-1}+f*2^{-2}+ ...   (d = 1) $  
$ 1 + 0.2 = e*2^0+f*2^{-1}+g*2^{-2}+ ...   (e = 1) $  
$ 0 + 0.4 = f*2^0+g*2^{-1}+h*2^{-2}+ ...   (f = 0) $  
$ 0 + 0.8 = g*2^0+h*2^{-1}+i*2^{-2}+ ...   (g = 0) $  
$ 1 + 0.6 = h*2^0+i*2^{-1}+j*2^{-2}+ ...   (h = 1) $  
....

```

然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……

## 浮点数的存储


