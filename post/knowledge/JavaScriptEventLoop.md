# JavaScript EventLoop

![EventLoop](./img/JavaScriptEventLoop.jpg)

## javascript 单线程, 非阻塞

?> javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。  
   单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。

!> 单线程是必要的，也是 JavaScript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果JavaScript 是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，JavaScript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

**从一个例子开始**

``` js
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```

打印顺序是什么？
正确答案是

``` output
script start
script end
promise1
promise2
setTimeout
```

但是在不同浏览器上的结果却是让人懵逼的。

>Microsoft Edge, Firefox 40, iOS Safari 和 desktop Safari 8.0.8在 `promise1`，`promise2` 之前打印了 `setTimeout`，--虽然看起来像竞态条件。[目前大部分浏览器已经支持]
?> 每个线程都会有它自己的`event loop`(事件循环)，所以都能独立运行。然而所有同源窗口会共享一个`event loop`以同步通信。`event loop`会一直运行，来执行进入队列的**宏任务**。一个`event loop`有多种的**宏任务源**（event等等），这些**宏任务源**保证了在本任务源内的顺序。但是浏览器每次都会选择一个源中的一个宏任务去执行。这保证了浏览器给与一些宏任务（如用户输入）以更高的优先级。

## 浏览器环境下js引擎的事件循环机制

### 1.执行栈与事件队列

当 JavaScript 代码执行的时候会将不同的变量存于内存中的不同位置：**堆（heap）**和**栈（stack）**中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。

?> 当我们调用一个方法的时候，js会生成一个与这个方法对应的**执行环境（context）**，又叫**执行上下文**。这个执行环境中存在着这个方法的**私有作用域，上层作用域的指向，方法的参数**，这个作用域中定义的**变量**以及这个作用域的 **`this` 对象**。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为**执行栈**。

?> 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。

!> 一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。

以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是**非阻塞**，实现这一点的关键在于下面要说的这项机制——**事件队列（Task Queue）**。

> js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入**与当前执行栈不同的另一个队列**，我们称之为**事件队列**。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这个过程被称为 **事件循环（Event Loop）**。

### 2. 宏任务（macro task）与微任务（micro task）

以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：**微任务（micro task）和宏任务（macro task）**。

以下事件属于宏任务：

- setInterval()
- setTimeout()

以下事件属于微任务

- new Promise()
- new MutaionObserver()

### 3. 宏任务队列(macrotask queue)与微任务队列(microtask queue)

在一个事件循环中，异步事件返回结果后会被放到一个**任务队列**中。然而，根据这个异步事件的类型，这个事件实际上会被对应的**宏任务队列**或者**微任务队列**中去。

?> 在当前执行栈为空的时候，主线程会查看**微任务队列**是否有事件存在。如果不存在，那么再去**宏任务队列**中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

!> tips: 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。**同一次事件循环中，微任务永远在宏任务之前执行**。

- macrotask queue：不唯一，存在一定的优先级（用户I/O部分优先级更高）；异步执行，**同一事件循环中，只执行一个**。

- microtask queue：唯一，整个事件循环当中，仅存在一个；执行为同步，**同一个事件循环中的microtask会按队列顺序，串行执行完毕**；

## 参考文献

<https://zhuanlan.zhihu.com/p/33058983>

<https://segmentfault.com/a/1190000014940904>
